"use server";

import { db } from "@/lib/firebase";
import { collection, getDocs, doc, setDoc, writeBatch, getDoc, addDoc, updateDoc } from "firebase/firestore";

export type RepairStatus = "Cotización" | "Confirmado" | "En Reparación" | "Reparado" | "Entregado";

export type FunctionalityTestResult = "ok" | "fail" | "na";

export type FunctionalityTestResults = {
    cameraFront: FunctionalityTestResult;
    cameraBack: FunctionalityTestResult;
    chargingPort: FunctionalityTestResult;
    screen: FunctionalityTestResult;
    touch: FunctionalityTestResult;
    buttons: FunctionalityTestResult;
    earpiece: FunctionalityTestResult;
    speaker: FunctionalityTestResult;
    microphone: FunctionalityTestResult;
    wifi: FunctionalityTestResult;
    biometrics: FunctionalityTestResult;
    other?: string;
};


export type Repair = {
    id: string;
    customer: string;
    device: string; // This will now be the product to repair, e.g., "iPhone 14"
    technician: string;
    status: RepairStatus;
    entryDate: string; // Should be in a format that can include time, e.g., ISO string
    deviceType: 'Tablet' | 'Celular' | 'Reloj' | 'Laptop';
    problemDescription: string;
    imeiOrSn?: string;
    password?: string;
    evaluation?: string;
    functionalityTest?: FunctionalityTestResults;
};

// Omit 'id' as it will be auto-generated by Firestore
export type NewRepair = Omit<Repair, 'id' | 'status' | 'entryDate' | 'technician' | 'evaluation'>;

export async function addRepair(repairData: NewRepair) {
    const repairsCol = collection(db, 'repairs');
    const newDoc: Omit<Repair, 'id'> = {
        ...repairData,
        technician: "No Asignado",
        status: "Cotización",
        entryDate: new Date().toISOString(),
        evaluation: "",
    }
    await addDoc(repairsCol, newDoc);
}

export async function getRepairs(): Promise<Repair[]> {
    const repairsCol = collection(db, 'repairs');
    const repairsSnapshot = await getDocs(repairsCol);
    const repairsList = repairsSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Repair)).sort((a, b) => new Date(b.entryDate).getTime() - new Date(a.entryDate).getTime());
    return repairsList;
}

export async function getRepairById(id: string): Promise<Repair | null> {
    const repairDocRef = doc(db, 'repairs', id);
    const repairSnapshot = await getDoc(repairDocRef);

    if (repairSnapshot.exists()) {
        return { id: repairSnapshot.id, ...repairSnapshot.data() } as Repair;
    } else {
        return null;
    }
}

export async function updateRepair(id: string, data: Partial<Omit<Repair, 'id'>>) {
    const repairDocRef = doc(db, 'repairs', id);
    await updateDoc(repairDocRef, data);
    
    // Return the updated document
    const updatedDoc = await getDoc(repairDocRef);
    return { id: updatedDoc.id, ...updatedDoc.data() } as Repair;
}

export async function seedRepairs(repairs: Repair[]) {
    const repairsCol = collection(db, 'repairs');
    const batch = writeBatch(db);
    
    repairs.forEach(repair => {
        const docRef = doc(repairsCol, repair.id);
        const { id, ...repairData } = repair;
        batch.set(docRef, repairData);
    });

    await batch.commit();
}
